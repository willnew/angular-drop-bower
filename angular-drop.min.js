!function (window, document, undefined) {'use strict';function Draggable () {}function Droppable () {}function publishExternalAPI () {angular.module('ui.drop', [], ['$provide', function ($provide) {$provide.provider({$dnd: $dndProvider,$drag: $dragProvider,$drop: $dropProvider})}]).directive({draggable: draggableDirective,droppable: droppableDirective})}var currentDrag,matchesFn,_version = {full: '0.0.1-c8dcddb',major: '0',minor: '0',dot: '1',codeName: 'badger'},booleans = {'false': !1,'true': !0,'': !0},unconst = function (value) {if ('string' == typeof value) {var num
        if (booleans.hasOwnProperty(value))return booleans[value];num = parseInt(value, 10), num === num && (value = num)}return value},readonly = function (target, name, fn) {
      Object.defineProperty ? Object.defineProperty(target, name, {get: fn,set: function () {},configurable: !1,enumerable: !0}) : target.__defineGetter__ ? target.__defineGetter__(name, fn) : target[name] = fn()},CLASS_SELECTOR_REGEXP = /^(\s*(\.-?([a-z\u00A0-\u10FFFF]|(\\\d+))([0-9a-z\u00A0-\u10FFFF_-]|(\\\d+))*)\s*)+$/i,getMatchesFn = function () {var selectorFunctions = ['matches', 'matchesSelector', 'msMatchesSelector', 'mozMatchesSelector', 'webkitMatchesSelector', 'oMatchesSelector']
      if ('function' == typeof window.Element && 'object' == typeof window.Element.prototype) for (var i = 0,ii = selectorFunctions.length;i < ii;++i) {var name = selectorFunctions[i]
          if ('function' == typeof window.Element.prototype[name]) {var matches = window.Element.prototype[name]
            return function (jq, selector) {return matches.call(jq[0], selector)}}}return 'function' == typeof $ && 'function' == typeof $.prototype.is ? function (jq, selector) {return jq.is(selector)} : 'function' == typeof Sizzle && 'function' == typeof Sizzle.matchesSelector ? function (jq, selector) {return Sizzle.matchesSelector(jq[0], selector)} : function (jq, selector) {if (selector && CLASS_SELECTOR_REGEXP.test(selector))return selector = selector.replace(/\s+/g, '').replace('.', ' ').replace(/^\s+/, '').replace(/\s+$/, ''), jq.hasClass(selector);throw new Error('Only class-based selectors are supported in this browser.')}},matchesSelector = function (node, selector) {return 'function' != typeof matchesFn && (matchesFn = getMatchesFn()), matchesFn(node, selector)},DOM = {nodeEq: function (node, name) {return typeof ('string' === node.nodeName ? node.nodeName.toLowerCase() : node[0].nodeName).toLowerCase() === name},offset: function (node) {node = node.length ? node[0] : node;var win,box = {top: 0,left: 0},doc = node && node.ownerDocument
        if (doc)return doc = doc.documentElement, DOM.contains(doc, node) ? (angular.isFunction(node.getBoundingClientRect) && (box = node.getBoundingClientRect()), win = DOM.window(doc), {top: box.top + win.pageYOffset - doc.clientTop,left: box.left + win.pageXOffset - doc.clientLeft}) : box},contains: function (a, b) {var adown = 9 === a.nodeType ? a.documentElement : a,bup = b && b.parentNode
        return a === bup || !(!bup || 1 !== bup.nodeType || !DOM.contains(adown, bup))},window: function (node) {return node = 'undefined' == typeof node.nodeName && 'number' == typeof node.length ? node[0] : node, DOM.isWindow(node) ? node : 9 === node.nodeType && node.defaultView || node.ownerDocument && (node.ownerDocument.defaultView || node.ownerDocument.parentWindow)},isWindow: function (obj) {return obj && obj.document && obj.location && obj.alert && obj.setInterval},swapCss: function (element, css, callback, args) {var ret,prop,old = {}
        for (prop in css)old[prop] = element.style[prop], element.style[prop] = css[prop];ret = callback.apply(element, args || []); for (prop in css)element.style[prop] = old[prop];return ret},swapDisplay: /^(none|table(?!-c[ea]).+)/,cssShow: {position: 'absolute',visibility: 'hidden',display: 'block'},size: function (node) {function getHeightAndWidth (element) {return {width: element.offsetWidth,height: element.offsetHeight}}var jq = angular.element(node)
        return node = node.nodeName ? node : node[0], 0 === node.offsetWidth && DOM.swapDisplay.test(jq.css('display')) ? DOM.swapCss(node, DOM.cssShow, getHeightAndWidth, [node]) : getHeightAndWidth(node)},keepSize: function (node) {var css = DOM.size(node)
      return css.width = css.width + 'px', css.height = css.height + 'px', css},closest: function (node, value) {if (node = angular.element(node), $.fn && angular.isFunction($.fn.closest))return node.closest(value);node = node[0], value = value.toLowerCase();do if (node.nodeName.toLowerCase() === value)return angular.element(node); while (node = node.parentNode)}},draggableOptions = {dragKeepSize: 'keepSize',dragWithin: 'dragWithin'},draggableDirective = ['$drag', '$document', '$interpolate', '$timeout', function ($drag, $document, $interpolate, $timeout) {return {restrict: 'A',link: function (scope, element, attrs) {var options = {}
        angular.forEach(draggableOptions, function (name, attr) {'undefined' != typeof attrs[attr] && (options[name] = unconst($interpolate(attrs[attr], !1)(scope)))}), $drag.draggable(element, options)}}}],$dragProvider = function () {function fixup (event) {return angular.isUndefined(event) && (event = window.event || {pageX: 0,pageY: 0,preventDefault: function () {}}), angular.isFunction(event.preventDefault) || (event.preventDefault = function () {}), event}function isDraggable (thing) {return angular.isObject(thing) && thing.constructor === Draggable}function dragConstraints (value, element) {if ('' !== value.length)return constraintsFor(/^(\.|#)/.test(value) && $.fn && angular.isFunction($.fn.closest) ? element.parent().closest(value) : /^(\^|parent)$/.test(value) ? element.parent() : DOM.closest(element.parent(), value))}function constraintsFor (element) {if ('undefined' != typeof element && 0 !== element.length) {var constraints = DOM.offset(element),dimensions = DOM.size(element)
          return constraints.right = constraints.left + dimensions.width, constraints.bottom = constraints.top + dimensions.height, constraints}}function withinConstraints (c, x, y, w, h) {return x >= c.left && x + w <= c.right && y >= c.top && y + h <= c.bottom}this.$get = ['$document', '$drop', function ($document, $drop) {var $drag = {isDraggable: function (element) {return !!$drag.draggable(element, !1)},draggable: function (element, options) {element = angular.element(element);var $draggable = element.data('$draggable')
            return $draggable ? $draggable : options === !1 ? undefined : (options = angular.extend({delay: 500,distance: 1}, options || {}), $draggable = new Draggable, $draggable.element = element, $draggable.options = options, element.on('mousedown', function (e) {var toNode = e.toElement.nodeName
            'SELECT' !== toNode && 'INPUT' !== toNode && 'BUTTON' !== toNode && $draggable.dragStart()}), element.data('$draggable', $draggable), $draggable)}}
        return Draggable.prototype = {constructor: Draggable,dragStart: function (event) {event = fixup(event), event.preventDefault();var self = isDraggable(this) ? this : $drag.draggable(this)
              currentDrag && currentDrag.dragEnd(event), currentDrag = self, self.cssDisplay = self.element.css('display'), self.dimensions = DOM.size(self.element), self.hanging || (self.cssPosition = self.element.css('position'), self.options.keepSize && (self.keepSize = {width: self.element[0].style.width,height: self.element[0].style.height}, self.element.css(DOM.keepSize(self.element)))), 'string' == typeof self.options.dragWithin && (self.constraints = dragConstraints(self.options.dragWithin, self.element)), self.offset = self.positionAbs = DOM.offset(self.element), self.offset.scroll = !1, angular.extend(self.offset, {click: {top: event.pageY - self.offset.top,left: event.pageX - self.offset.left}}), self.lastMouseY = event.pageY, self.lastMouseX = event.pageX, self.startEvent = event, self.element.css({position: 'absolute',left: self.offset.left,top: self.offset.top}), $document.on('mousemove', self.drag), $document.on('mouseup', self.dragEnd)},dragEnd: function (event) {event.preventDefault(), $document.off('mousemove', self.drag), $document.off('mouseup', self.dragEnd), $drop.drop(event)},drag: function (event) {event = fixup(event), event.preventDefault();var self = currentDrag
              if (self) {var nx,ny,style = self.element.prop('style'),computedStyle = window.getComputedStyle(self.element[0], null),position = {top: event.pageY,left: event.pageX},x = computedStyle.getPropertyValue('left').replace('px', '') || 0,y = computedStyle.getPropertyValue('top').replace('px', '') || 0
              ny = parseInt(y, 10) + (position.top - self.lastMouseY), nx = parseInt(x, 10) + (position.left - self.lastMouseX), self.constraints && !withinConstraints(self.constraints, nx, ny, self.dimensions.width, self.dimensions.height) || (style.left = nx + 'px', style.top = ny + 'px'), self.lastMouseY = position.top, self.lastMouseX = position.left}},finish: function () {this.element.css({position: this.cssPosition}), this.dimensions = undefined, currentDrag = undefined}}, readonly($drag, 'current', function () {return currentDrag}), readonly($drag, 'version', function () {return _version}), $drag}], readonly(this, 'version', function () {return _version})},droppableDirective = ['$drop', '$parse', function ($drop, $parse) {return {restrict: 'A',compile: function ($element, $attrs) {return function (scope, element, attrs) {var allowed = $parse(attrs.dropAllowed || 'undefined')(scope),droppable = $drop.droppable(element)
          allowed && droppable.allowedSelectors(allowed)}}}}],$dropProvider = function () {this.$get = ['$document', '$rootScope', function ($document, $rootScope) {var $drop = {isDroppable: function (element) {return !!$drag.droppable(element, !1)},droppable: function (element, options) {element = angular.element(element);var $droppable = element.data('$droppable')
            return $droppable ? $droppable : options === !1 ? undefined : (options = angular.extend({constraints: null,delay: 500,distance: 1}, options || {}), $droppable = new Droppable, $droppable.element = element, $droppable.options = options, element.data('$droppable', $droppable), $droppable)},drop: function (x, y) {function badDrop () {current.hanging = !0, current.element.css({display: current.cssDisplay}), currentDrag = undefined, $rootScope.$emit('$badDrop', current)}if (currentDrag && ('undefined' == typeof x && (x = window.event), angular.isObject(x) && ('number' == typeof x.clientX && 'number' == typeof x.clientY ? (y = x.clientY, x = x.clientX) : 'number' == typeof x.left && 'number' == typeof x.top && (y = x.top, x = x.left)), 'number' == typeof x && 'number' == typeof y)) {var element,$droppable,current = currentDrag
              return current.element.css({display: 'none'}), (element = document.elementFromPoint(x, y)) ? (3 === element.nodeType && (element = element.parentNode), element = angular.element(element), $droppable = element.inheritedData('$droppable'), $droppable && this.dropAllowed($droppable, current.element) ? ($droppable.drop(current), !0) : badDrop()) : badDrop()}},dropAllowed: function (droppable, draggable) {var allowed = droppable.allowedSelectors()
            if (!allowed || !angular.isArray(allowed))return !0; for (var i = 0;i < allowed.length;++i) {var curAllowed = allowed[i]
            if ('string' == typeof curAllowed && matchesSelector(draggable, curAllowed))return !0}return !1}}
        return Droppable.prototype = {constructor: Droppable,drop: function (draggable, options) {draggable = draggable || currentDrag, ('number' == typeof draggable.length || draggable.nodeName) && (draggable = angular.element(draggable).data('$draggable')), draggable && draggable.constructor === Draggable && (options = angular.extend(options || {}, {display: draggable.cssDisplay}), this.element.append(draggable.element), draggable.options.keepSize && (draggable.element.css(draggable.keepSize), draggable.keepSize = undefined), draggable.element.css({display: options.display}), draggable.hanging = !1, $rootScope.$$phase || $rootScope.$apply(), draggable.finish())},allowedSelectors: function (allowedSelectors) {return arguments.length > 0 ? ('string' == typeof allowedSelectors && (allowedSelectors = allowedSelectors.split(',')), angular.isArray(allowedSelectors) && (this.allowed = allowedSelectors), this) : this.allowed}}, readonly($drop, 'version', function () {return _version}), $drop}], readonly(this, 'version', function () {return _version})},$dndProvider = function () {this.$get = [function () {var $dnd = {}
        return readonly($dnd, 'current', function () {return currentDrag}), readonly($dnd, 'version', function () {return _version}), $dnd}], readonly(this, 'version', function () {return _version})}
  publishExternalAPI()}(window, document)
